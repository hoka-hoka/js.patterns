[1. Observer](Observer)

[2. PublisherSubscribe]()

### Observer
Шаблон Observer – это шаблон, в котором объект, называемый subject или субъект, ведёт список зависимых объектов, называемых observers или наблюдатели, и автоматически уведомляет их о любых изменениях состояния, обычно вызывая один из их методов.
subject содержит ссылку на всех своих слушателей, а observer, в свою очередь содержит ссылку на subject, на который он подписан.
Основные участники патерна Observer:
1.  Subject. Хранит информацию о своих наблюдателях и позволяет их добавлять и удалять.
2.  Observer. Наблюдатель, определяет интерфейс обновления для объектов, которые должны быть уведомлены об изменении состояния субъекта.
Примером subject выступает встроенный в js объект, наблюдающий за DOM-элементами и запускающий колбэк в случае изменений. Callback вызывается при каждом изменении DOM-элемента.

### PubSub
Publisher-Subscriber очень похож на Observer. Subject уведомляет Observer о событии также, как Publisher (издатель) уведомляет своих Subscribers (подписчиков), путём вызова у них какой-либо функции, инициализирующей обновление подписчика.  

Основное отличие между этими шаблонами заключается в следующем. В шаблоне Publisher-Subscriber отправители сообщений, называемые publishers, сами ничего не знат о получателях subscribers, соответственно не создают сообщений, которые будут отправлены определённым получателям.

На деле получается, что Observer и PubSub есть один и тот же шаблон с субъектом или издателем, который ведёт список слушателей или подписчиков, а также реализует интерфейс регистрации на событие или подписку и оповещение или публикацию в зависимости от терминалогии. Но тогда в чём между ними разница?. Отличаются они способом применения.

Если рассмотреть Observer, то когда небыло классов, subject реализовывался через функцию конструктор и расширялся через прототипирование. Затем создавался instance, который унаследовал методы реализации интерфейса subject. Таким образом в модели Observer есть конкретный instanceSubject, который отвечает за публикацию событий, а observers слушают только его.

С появлением классов стало проще выполнять наследование. При использовании объекта PublisherSubsrcribers его работа делегируется на прослойку. Часто такой прослойкой выступает какой-нибудь класс. Таким образом этот класс получает права на публикацию сообщений, а подписчики начинают работать не с основным издателем (которого может и не быть, а только существовать статический класс), а с его доверительным партнёром, которому первый прередал полномочия. В результате между publishers и subscribers нет прямой связи. Таких прослоек может быть несколько и они все могут обрабатывать одну и ту же базу подписчиков.

Например, если наше приложение строится по модели шаблона проектирования MVC, то при регистрации методов в Model или Controller, именно эти классы могут выполнять роль посредников между publishers и subscribers.

Реализация PubSub намного гибче, чем Observer, к тому же его можно использовать, как Observer, возможно, именно поэтому число реализаций плагинов PubSub преобладает над плагинами Observer.

<p align="center">
  <img src="https://github.com/hoka-hoka/js.patterns/blob/master/src/img/Observer_PubSub.png"/>
</p>
<div align="center">Рисунок 1 - Шаблоны Observer и PubSub</div>

Subscribers - это подписчики. Внутри этого объекта хранятся пары ключ/значение событий. Каждое событие будет иметь ключ, соответствующий имени события, и значение, установленное для массива. В этом масиве регистрируются/хранятся обработанные вызовы подписчиков.

Сам модуль pubsub экспортирует две функции. Одну publish для публикации обновлений, а другую subscribe подписки на обновление.
